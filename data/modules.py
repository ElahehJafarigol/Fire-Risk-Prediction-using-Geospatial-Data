# -*- coding: utf-8 -*-
"""modules.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BI2KQokfI8d6KYbKZD5mI0VTHBHNFTqK
"""

import os
import h5py
import numpy as np
import pandas as pd
import xarray as xr
from tqdm import tqdm
import geopandas as gpd
from shapely import box
from pyhdf.SD import SD, SDC
from datetime import datetime
from scipy.spatial import cKDTree
from shapely.geometry import Polygon, MultiPolygon

"""# Fire"""

def load_and_clip_water_features(lakes_path, ocean_path, extent, plot=True):
    """
    Load lakes and ocean shapefiles, merge and clip them to a bounding box.

    Parameters:
        lakes_path (str): Path to the lakes shapefile (e.g., ne_10m_lakes.shp)
        ocean_path (str): Path to the ocean shapefile (e.g., ne_10m_ocean.shp)
        extent (list): Bounding box as [min_lon, max_lon, min_lat, max_lat]
        plot (bool): Whether to show a plot of the clipped water features

    Returns:
        GeoDataFrame: Clipped water features within the given extent
    """
    # Load shapefiles
    lakes = gpd.read_file(lakes_path)
    ocean = gpd.read_file(ocean_path)

    # Merge and enforce CRS
    water = gpd.GeoDataFrame(pd.concat([lakes, ocean], ignore_index=True), crs="EPSG:4326")

    # Create bounding box polygon
    bbox = box(extent[0], extent[2], extent[1], extent[3])
    bbox_gdf = gpd.GeoDataFrame(geometry=[bbox], crs="EPSG:4326")

    # Clip
    water_clipped = gpd.overlay(water, bbox_gdf, how="intersection")

    # Optional plot
    if plot:
        ax = bbox_gdf.plot(edgecolor="black", facecolor="none", figsize=(10, 10))
        water_clipped.plot(ax=ax, color="skyblue", alpha=0.5)
        ax.set_title("Ocean & Lakes Mask")
        ax.set_xlabel("Longitude")
        ax.set_ylabel("Latitude")
        plt.tight_layout()
        plt.show()

    return water_clipped

def convert_multipolygon(geometry):
    if geometry.geom_type == "MultiPolygon":
        return max(geometry.geoms, key=lambda p: p.area)
    return geometry

def load_fire_data(filepath, bbox):
    fires = gpd.read_file(filepath)
    fires = fires.to_crs(epsg=4326)
    fires = fires[fires.geometry.intersects(bbox)]
    fires["geometry"] = fires["geometry"].apply(convert_multipolygon)
    return fires

def load_infrastructure_data(roads_path, urban_area_path, bbox):
    roads = gpd.read_file(roads_path).to_crs(epsg=4326)
    urban_area = gpd.read_file(urban_area_path).to_crs(epsg=4326)

    roads = roads[roads.geometry.intersects(bbox)]
    urban_area = urban_area[urban_area.geometry.intersects(bbox)]

    return roads, urban_area

def process_fire_data(fire_data, urban_area_data, roads_data):
    projected_crs = "EPSG:32611"  # Use a projected CRS for accurate distance calculations

    # Reproject all inputs
    fires = fire_data.to_crs(projected_crs)
    urban_area = urban_area_data.to_crs(projected_crs)
    roads = roads_data.to_crs(projected_crs)

    # Compute fire centroids in projected CRS
    fires["centroid"] = fires.geometry.centroid

    # Compute distances from centroid to nearest road and urban area
    fires["distance_to_urban_areas"] = fires["centroid"].apply(lambda x: urban_area.distance(x).min())
    fires["distance_to_roads"] = fires["centroid"].apply(lambda x: roads.distance(x).min())

    # Reproject everything back to WGS84 for output
    fires = fires.to_crs(epsg=4326)

    # Compute final lat/lon from centroid in EPSG:4326
    with warnings.catch_warnings():
        warnings.filterwarnings("ignore", message="Geometry is in a geographic CRS.*")
        fires["fire_centroid"] = fires.geometry.centroid
    fires["lat"] = fires['fire_centroid'].y
    fires["lon"] = fires['fire_centroid'].x

    fires_df = pd.DataFrame(fires)
    fires_df["date"] = pd.to_datetime(fires_df["ALARM_DATE"]).dt.date

    fires_df = fires_df.rename(columns={
    "ALARM_DATE": "fire_start_date",
    "CONT_DATE": "fire_contained_date",
    "Shape__Are": "fire_area_m2",
    "Shape__Len": "fire_perimeter_m",
    "geometry": "fire_geometry",
    "date": "date",
    "CAUSE" : "fire_cause",
    "FIRE_NAME": "fire_name"
    })

    # Prepare GeoDataFrame
    fires_gdf = gpd.GeoDataFrame(fires_df, geometry='fire_geometry', crs="EPSG:4326")
    return fires_df, fires_gdf

def plot_fire_overlay_map(
    fires_gdf,
    urban_area,
    aoi_image,
    output_path,
    extent=None,
    bbox=None,
    title="Fire Polygons Overlaid on Target Area"
):
    """
    Plots fire polygons and centroids over a base image with clipped urban areas.

    Parameters:
        fires_df (GeoDataFrame): Must include columns 'fire_geometry', 'fire_centroid', 'lon', 'lat', 'fire_name'.
        urban_area (GeoDataFrame): Urban polygons in EPSG:4326.
        aoi_image (array): Loaded PNG (e.g., via matplotlib.image.imread).
        output_path (str): Path to save the output image.
        extent (list): Optional [min_lon, max_lon, min_lat, max_lat]; auto-computed if None.
        bbox (shapely.geometry.box): Optional bounding box geometry; auto-computed if None.
        title (str): Title of the plot.
    """

    # Compute bounding box and extent if not provided
    if extent is None:
        bounds = fires_gdf.total_bounds  # [minx, miny, maxx, maxy]
        extent = [bounds[0], bounds[2], bounds[1], bounds[3]]  # [min_lon, max_lon, min_lat, max_lat]

    if bbox is None:
        bbox = box(extent[0], extent[2], extent[1], extent[3])

    # Plot setup
    fig, ax = plt.subplots(figsize=(12, 12))
    ax.imshow(aoi_image, extent=extent)

    # Plot fire perimeters and centroids
    fires_gdf.boundary.plot(ax=ax, edgecolor='orange', linewidth=1.5, label='Fire Perimeters')
    fires_gdf.set_geometry('fire_centroid').plot(ax=ax, color='black', markersize=20, label='Centroids')

    # Label each fire
    for _, row in fires_gdf.iterrows():
        ax.text(row["lon"], row["lat"], row["fire_name"], fontsize=6, color="white")

    # Clip and plot urban areas
    urban_clipped = urban_area[urban_area.geometry.intersects(bbox)].copy()
    urban_clipped.geometry = urban_clipped.geometry.intersection(bbox)
    urban_clipped.plot(ax=ax, color='deepskyblue', edgecolor='gray', alpha=0.3, label='Urban Areas')

    # Legend
    fire_patch = mlines.Line2D([], [], color='orange', linewidth=1.5, label='Fire Perimeters')
    centroid_patch = mlines.Line2D([], [], color='black', marker='o', linestyle='None', markersize=6, label='Centroids')
    urban_patch = mpatches.Patch(color='deepskyblue', alpha=0.3, label='Urban Areas')

    ax.set_title(title)
    ax.set_xlabel("Longitude")
    ax.set_ylabel("Latitude")
    ax.legend(handles=[fire_patch, centroid_patch, urban_patch], loc='upper right')
    plt.grid(False)
    plt.tight_layout()
    plt.show()

    # Save
    fig.savefig(output_path, dpi=300)
    print(f"Saved to {output_path}")

def generate_non_fire_samples(
    fires_gdf,
    bbox,
    num_samples=1000,
    multiplier=2,
    crs="EPSG:4326",
    water_mask_gdf=None
    ):
    """
    Generate random non-fire points within bbox,
    excluding fire perimeters and optional water mask areas.
    """

    print("Generating non-fire points...")

    # Create AOI polygon
    aoi_poly = gpd.GeoSeries([bbox], crs=crs)

    # Combine all fire perimeters into one
    fire_union = fires_gdf.geometry.union_all()

    # Mask fire areas from AOI
    non_fire_area = aoi_poly[0].difference(fire_union)

    # Further mask water if provided
    if water_mask_gdf is not None:
        water_union = water_mask_gdf.geometry.unary_union
        non_fire_area = non_fire_area.difference(water_union)

    # GeoSeries to sample from
    non_fire_zone = gpd.GeoSeries([non_fire_area], crs=crs)

    # Estimate number of non-fire samples

    num_fire = len(fires_gdf)
    num_non_fire = int(num_fire * multiplier)

    # Sampling loop
    samples = []
    minx, miny, maxx, maxy = non_fire_zone.total_bounds
    attempts = 0

    with tqdm(total=num_non_fire, desc="Sampling non-fire points") as pbar:
        while len(samples) < num_non_fire and attempts < num_non_fire * 10:
            x = np.random.uniform(minx, maxx)
            y = np.random.uniform(miny, maxy)
            point = Point(x, y)
            if non_fire_zone.contains(point).any():
                samples.append(point)
                pbar.update(1)
            attempts += 1

    print(f"\nGenerated {len(samples)} non-fire points from {attempts} attempts.")

    # Format result as GeoDataFrame
    non_fire_gdf = gpd.GeoDataFrame(geometry=samples, crs=crs)
    non_fire_gdf["lat"] = non_fire_gdf.geometry.y
    non_fire_gdf["lon"] = non_fire_gdf.geometry.x
    non_fire_gdf["fire_label"] = 0

    return non_fire_gdf

def plot_fire_vs_nonfire_samples(
    fire_gdf,
    non_fire_gdf,
    urban_area,
    water_clipped,
    AOI_image,
    extent,
    output_path,
    bbox_coords=[-120.37687115, 33.30371742, -116.82364793, 35.15580029],
    title="Fire vs Non-Fire Sample Locations"
    ):
    """
    Visualize fire and non-fire samples, urban areas, and water bodies over a base AOI image.

    Parameters:
        fire_gdf (GeoDataFrame): Fire GeoDataFrame including 'fire_geometry' and 'fire_centroid'.
        non_fire_gdf (GeoDataFrame): GeoDataFrame of non-fire sample points.
        urban_area (GeoDataFrame): Urban area polygons (EPSG:4326).
        water_clipped (GeoDataFrame): Clipped water mask polygons.
        AOI_image (np.array): Background image array (already loaded).
        extent (list): [min_lon, max_lon, min_lat, max_lat] for AOI image.
        output_path (str): Path to save the output figure (PNG).
        bbox_coords (list): Optional bbox [min_lon, min_lat, max_lon, max_lat] to clip urban areas.
        title (str): Title of the plot.
    """

    # Setup
    fig, ax = plt.subplots(figsize=(12, 12))
    ax.imshow(AOI_image, extent=extent)

    # Geometry setup
    fire_gdf = gpd.GeoDataFrame(fire_gdf, geometry='fire_geometry', crs="EPSG:4326")
    centroids = gpd.GeoSeries(fire_gdf["fire_centroid"], crs="EPSG:4326")

    # Plot fire perimeters and centroids
    fire_gdf.boundary.plot(ax=ax, edgecolor='orange', linewidth=1.5, label='Fire Perimeters')
    centroids.plot(ax=ax, color='black', markersize=20, label='Fire Centroids')

    # Plot non-fire points
    non_fire_gdf.plot(ax=ax, color='limegreen', markersize=15, marker='x', label='Non-Fire Points')

    # Clip and plot urban areas
    bbox = box(bbox_coords[0], bbox_coords[1], bbox_coords[2], bbox_coords[3])
    urban_clipped = urban_area[urban_area.geometry.intersects(bbox)].copy()
    urban_clipped.geometry = urban_clipped.geometry.intersection(bbox)
    urban_clipped.plot(ax=ax, color='purple', edgecolor='gray', alpha=0.3, label='Urban Areas')

    # Plot water mask
    water_clipped.plot(ax=ax, facecolor='skyblue', edgecolor='deepskyblue', alpha=0.4, label='Water Mask')

    # Legend
    fire_patch = mlines.Line2D([], [], color='orange', linewidth=1.5, label='Fire Perimeters')
    centroid_patch = mlines.Line2D([], [], color='black', marker='o', linestyle='None', markersize=8, label='Fire Centroids')
    non_fire_patch = mlines.Line2D([], [], color='limegreen', marker='x', linestyle='None', markersize=8, label='Non-Fire Points')
    urban_patch = mpatches.Patch(color='purple', alpha=0.3, label='Urban Areas')
    water_patch = mpatches.Patch(color='skyblue', alpha=0.4, label='Water Mask')

    ax.set_title(title)
    ax.set_xlabel("Longitude")
    ax.set_ylabel("Latitude")
    ax.legend(handles=[fire_patch, centroid_patch, non_fire_patch, urban_patch, water_patch], loc='upper right')
    plt.grid(False)
    plt.tight_layout()
    plt.show()

    # Save
    fig.savefig(output_path, dpi=300)
    print(f"Figure saved to: {output_path}")

"""# Climate"""

def load_climate_data(humidity_path, temperature_path, wind_path):
    humidity = xr.open_dataset(humidity_path)
    temperature = xr.open_dataset(temperature_path)
    wind = xr.open_dataset(wind_path)
    climate = xr.merge([humidity, temperature, wind])
    climate_df = climate.to_dataframe().reset_index()
    return climate_df

"""# Vegetation"""

def extract_ndvi(hdf_files, lat_range, lon_range, output_file):
    lat_min, lat_max = lat_range
    lon_min, lon_max = lon_range

    sample_hdf = SD(hdf_files[0], SDC.READ)
    ndvi_sample = sample_hdf.select("250m 16 days NDVI")[:]
    nrows, ncols = ndvi_sample.shape

    lat_values = np.linspace(lat_max, lat_min, nrows)
    lon_values = np.linspace(lon_min, lon_max, ncols)
    lat_grid, lon_grid = np.meshgrid(lat_values, lon_values, indexing="ij")

    lat_flat = lat_grid.ravel()
    lon_flat = lon_grid.ravel()

    for file in tqdm(hdf_files, desc="Processing NDVI Files", unit="file"):
        hdf_file = SD(file, SDC.READ)
        ndvi_data = hdf_file.select("250m 16 days NDVI")[:]
        ndvi_data = np.where(ndvi_data == -3000, np.nan, ndvi_data)

        date_str = file.split(".")[1][1:]
        date_obj = datetime.strptime(date_str, "%Y%j").date()

        ndvi_flat = ndvi_data.ravel()
        ndvi_df = pd.DataFrame({"lat": lat_flat, "lon": lon_flat, "NDVI": ndvi_flat, "date": date_obj})
        ndvi_df.to_csv(output_file, mode='a', header=not os.path.exists(output_file), index=False)

"""# Elevation and Canopy Height (GEDI)"""

def load_gedi_data(file_path, beam_name="BEAM0001"):
    with h5py.File(file_path, "r") as hdf_file:
        beam = hdf_file[beam_name]

        elevation = beam["digital_elevation_model"][:]
        elevation = np.where(elevation < 0, np.nan, elevation).flatten()

        e_lat = beam["lat_lowestmode"][:].flatten()
        e_lon = beam["lon_lowestmode"][:].flatten()

        canopy_height = beam['elev_highestreturn'][:]
        canopy_height = np.where(canopy_height < 0, np.nan, canopy_height)

        c_lat = beam["lat_highestreturn"][:].flatten()
        c_lon = beam["lon_highestreturn"][:].flatten()

    elevation_df = pd.DataFrame({"lat": e_lat, "lon": e_lon, "elevation": elevation})
    canopy_df = pd.DataFrame({"lat": c_lat, "lon": c_lon, "canopy_height": canopy_height})

    return elevation_df, canopy_df


def combine_gedi_datasets(gedi_files):
    elevation_frames, canopy_frames = [], []

    for file in gedi_files:
        elevation_df, canopy_df = load_gedi_data(file)
        elevation_frames.append(elevation_df)
        canopy_frames.append(canopy_df)

    combined_elevation_df = pd.concat(elevation_frames, ignore_index=True)
    combined_canopy_df = pd.concat(canopy_frames, ignore_index=True)

    return elevation_df, canopy_df


def spatial_merge_elevation_canopy(elevation_df, canopy_df):
    elevation_gdf = gpd.GeoDataFrame(elevation_df,
                                     geometry=gpd.points_from_xy(elevation_df.lon, elevation_df.lat),
                                     crs="EPSG:4326")

    canopy_gdf = gpd.GeoDataFrame(canopy_df,
                                  geometry=gpd.points_from_xy(canopy_df.lon, canopy_df.lat),
                                  crs="EPSG:4326")

    elevation_gdf = elevation_gdf.to_crs(epsg=3310)
    canopy_gdf = canopy_gdf.to_crs(epsg=3310)

    elevation_canopy_gdf = gpd.sjoin_nearest(elevation_gdf, canopy_gdf,
                                             how="left", distance_col="distance_to_nearest")

    elevation_canopy_gdf = elevation_canopy_gdf.to_crs(epsg=4326)

    elevation_canopy_gdf['lat'] = elevation_canopy_gdf['lat_right']
    elevation_canopy_gdf['lon'] = elevation_canopy_gdf['lon_right']
    elevation_canopy_gdf = elevation_canopy_gdf.drop(['lat_left', 'lon_left', 'lat_right', 'lon_right'], axis=1)
    return elevation_canopy_gdf


def nearest_neighbor(source_df, target_df, source_cols, target_cols):
    source_coords = source_df[source_cols].to_numpy()
    target_coords = target_df[source_cols].to_numpy()

    tree = cKDTree(target_coords)  # Build KDTree for fast spatial lookup
    distances, indices = tree.query(source_coords, k=1)  # Find nearest match

    return target_df.iloc[indices][target_cols].reset_index(drop=True)

"""# Merge"""

def merge_datasets(fires_df, climate_df, ndvi_df, elevation_canopy_df):
    source_cols = ["lat", "lon"]

    # Merge Climate Data (Temperature, Humidity, Wind Speed)
    fires_df[["T2M", "QV2M", "WS10M"]] = nearest_neighbor(fires_df, climate_df, source_cols, ["T2M", "QV2M", "WS10M"])

    # Merge NDVI Data
    fires_df["NDVI"] = nearest_neighbor(fires_df, ndvi_df, source_cols, ["NDVI"])

    # Merge Elevation & Canopy Height Data
    fires_df["elevation"] = nearest_neighbor(fires_df, elevation_canopy_df, source_cols, ["elevation"])
    fires_df["canopy_height"] = nearest_neighbor(fires_df, elevation_canopy_df, source_cols, ["canopy_height"])

    return fires_df